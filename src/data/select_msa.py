import os
import argparse
import subprocess
import numpy as np
import pandas as pd


def run_gremlin(alignment_file, output_dir, gremlin_executable='gremlin'):
    """
    Runs GREMLIN on the given alignment file.

    Parameters:
    - alignment_file (str): Path to the A2M alignment file.
    - output_dir (str): Directory to store GREMLIN output files.
    - gremlin_executable (str): Path to the GREMLIN executable.

    Returns:
    - ec_file (str): Path to the EC output file generated by GREMLIN.
    """
    # Create output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Construct the output EC file path
    sequence_id = os.path.splitext(os.path.basename(alignment_file))[0]
    ec_file = os.path.join(output_dir, f'{sequence_id}.ec')

    # GREMLIN command
    cmd = [
        gremlin_executable,
        '-i', alignment_file,
        '-o', ec_file
    ]

    print(f"Running GREMLIN on {alignment_file}...")
    try:
        subprocess.run(cmd, check=True)
        print(f"GREMLIN output saved to {ec_file}")
    except subprocess.CalledProcessError as e:
        print(f"An error occurred while running GREMLIN on {alignment_file}: {e}")
        return None

    return ec_file

def parse_ec_file(ec_file):
    """
    Parses the EC output file generated by GREMLIN.

    Parameters:
    - ec_file (str): Path to the EC output file.

    Returns:
    - ec_df (pd.DataFrame): DataFrame containing EC scores with columns ['i', 'j', 'cn'].
    """
    try:
        ec_df = pd.read_csv(ec_file, delim_whitespace=True, header=None, names=['i', 'j', 'cn'])
        return ec_df
    except Exception as e:
        print(f"An error occurred while parsing {ec_file}: {e}")
        return None

def count_significant_ecs(ec_df, L):
    """
    Counts the number of significant ECs in the EC DataFrame.

    Parameters:
    - ec_df (pd.DataFrame): DataFrame containing EC scores with columns ['i', 'j', 'cn'].
    - L (int): Sequence length.

    Returns:
    - significant_ecs_count (int): Number of significant ECs.
    """
    # Apply sequence separation filter (e.g., |i - j| > 4)
    ec_df_filtered = ec_df[abs(ec_df['i'] - ec_df['j']) > 4]

    # Sort by coupling score (descending order)
    ec_df_sorted = ec_df_filtered.sort_values(by='cn', ascending=False)

    # Select top L ECs
    top_L_ecs = ec_df_sorted.head(L)

    # Count the number of significant ECs
    significant_ecs_count = len(top_L_ecs)

    return significant_ecs_count

def get_sequence_length(alignment_file):
    """
    Determines the sequence length from the alignment file.

    Parameters:
    - alignment_file (str): Path to the A2M alignment file.

    Returns:
    - L (int): Sequence length.
    """
    try:
        with open(alignment_file, 'r') as f:
            for line in f:
                if not line.startswith('>'):
                    seq = line.strip()
                    L = len(seq.replace('-', '').replace('.', ''))
                    return L
    except Exception as e:
        print(f"An error occurred while reading {alignment_file}: {e}")
    return None

if __name__ == "__main__":
    # Path to GREMLIN executable (adjust if necessary)
    # gremlin_executable = '/path/to/gremlin'  # Replace with the actual path or 'gremlin' if in PATH

    # List of A2M alignment files
    alignment_files = [
        'jackhmmer_results/BFP_uniref100/bitscore_0.1.a2m',
        'jackhmmer_results/BFP_uniref100/bitscore_0.2.a2m',
        # Add more files as needed
    ]

    best_alignment = ''
    max_significant_ecs = 0

    # Dictionary to store results
    results = {}

    for alignment_file in alignment_files:
        # Ensure the file exists
        if not os.path.isfile(alignment_file):
            print(f"File not found: {alignment_file}")
            continue

        sequence_id = os.path.splitext(os.path.basename(alignment_file))[0]
        output_dir = f'gremlin_results_{sequence_id}'

        # Get sequence length
        L = get_sequence_length(alignment_file)
        if L is None:
            print(f"Could not determine sequence length for {alignment_file}")
            continue

        # Run GREMLIN
        ec_file = run_gremlin(alignment_file, output_dir)
        if ec_file is None:
            continue  # Skip to next file if GREMLIN failed

        # Parse EC file
        ec_df = parse_ec_file(ec_file)
        if ec_df is None:
            continue  # Skip to next file if parsing failed

        # Count significant ECs
        significant_ecs_count = count_significant_ecs(ec_df, L)

        print(f"{alignment_file}: {significant_ecs_count} significant ECs\n")

        # Store the result
        results[alignment_file] = significant_ecs_count

        # Update the best alignment if necessary
        if significant_ecs_count > max_significant_ecs:
            max_significant_ecs = significant_ecs_count
            best_alignment = alignment_file

    # Output the best alignment
    if best_alignment:
        print(f"Best alignment is {best_alignment} with {max_significant_ecs} significant ECs")
    else:
        print("No valid alignments were processed.")

    # Optionally, print all results
    print("\nAll results:")
    for alignment_file, count in results.items():
        print(f"{alignment_file}: {count} significant ECs")